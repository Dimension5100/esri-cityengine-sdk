<html>

<head>
    <title>
     Occlusion Query Functions
    </title>
    <link rel="stylesheet" href="../manual_style.css" type="text/css">
</head>

<body>
<div class="content">

<!-- HEADER (use only on bookchapters) -->

    <table summary="" class="header">
        <tr>
            <td align="left" class="helphead_l"><a href="../toc.html"><div class="helplink">&nbsp;</div></a></td>
            <td align="right" class="helphead_r"></td>
        </tr>
    </table>


<!-- CONTENT -->

        <h1>
        inside / overlaps / touches functions (occlusion queries)
        </h1>
        <h2>
        Synopsis
        </h2>
        <p class="code2">bool inside()</p>
        <p class="code2">bool inside(<span class="cga_opparam">target-selector</span>)</p>
  <p class="code2">bool overlaps()</p>
        <p class="code2">bool overlaps(<span class="cga_opparam">target-selector</span>)</p>
        <p class="code2">bool touches()</p>
        <p class="code2">bool touches(<span class="cga_opparam">target-selector</span>)</p>
        <h2>Parameters </h2>
        <ul>
          <li><span class="cga_opparam">target-selector</span><br>
(<span class="code_std">all | intra | inter</span>) Target selector for the query. <span class="code_std">intra</span> just checks against shapes in the same shape tree, <span class="code_std">inter</span> just checks against shapes in other shape trees (i.e. neighboring models of different initial shapes) and <span class="code_std">all</span> checks both. If no selector is given, <span class="code_std">all</span> is used.</li>
        </ul>
<h2>
        Returns</h2>
  <p><span class="cga_keyword">true</span> if the geometry of the current shape lies fully <em>inside</em>, <em>overlaps</em>, or
  <em>touches</em> the geometry of another shape, respectively.		</p>

<p class="info">
An occlusion query tests for intersections between shapes. There are four different boolean functions available to examine the spatial context of the geometry of the current shape:
<ul>
	<li><span class="code_std">inside(selector)</span> returns true if the geometry of the current shape is completely inside one of the shapes specified with selector.</li>
	<li><span class="code_std">overlaps(selector)</span> returns true if the geometry of the current shape volumetrically overlaps one of the specified shapes.</li>
	<li><span class="code_std">touches(selector)</span> returns true if the geometry of the current shape overlaps or touches the surface of one of the specified shapes.</li>
</ul>    
The functions are typically applied in the conditional part of a rule. A visual definition of the four occlusion functions is given in the figure below.</p> 

<br><p class="piccaptioncentered"><img src="images/occlusiontests.png"><br>
Table with occlusion query functions and their results for the five configurations between two 2D polygons; the polygon configurations extend naturally to (closed) 3D surfaces.</p>


<p>
For all functions, the parameter selector determines what the current geometry is tested against and can either be all (default), intra, inter, or a specific shape symbol. Thus, the current geometry can be tested against geometries of shapes in both the same model (intra-occlusion i.e. any shape in the current shape-tree) and neighboring models (inter-occlusion i.e. whole shape-trees generated by other neighboring initial shapes). In any case, tests can only be performed against geometries which form a closed surface (i.e. a waterproof mesh which has no boundary edges), other geometries are ignored.</p>
<p>


Let us look at a concrete example. The picture below shows a building model. First the rules generated an U-shaped mass model by using the subdivision split operation. 
As a consequence, the geometries of the side wings touch the geometry of the main block and unrealistically intersected windows are generated. 
<br><p class="piccaptioncentered"><img src="images/occlusion-modern-building.png"><br>
Left: No occlusion queries are used. Center: Occluded windows are colored red. Right: In the final model, occluded windows are dropped.</p>


The rule which constructs the windows looks like this:
    <pre class="code3">
WindowOpening--> Sill s('1,'1,windowSetback) t(0,0,'-1) [ i(openbox) Wall ] Window
</pre>
The rule first invokes the generation of a window sill, then sets the size of the scope to the depth of the window setback and translates the scope accordingly. Afterwards the openbox asset is inserted to model the wall on the side of the window opening. Finally the actual Window generation is invoked. <br>

To make this rule react to the above mentioned occlusions, we just have to add a simple touches() condition:
    <pre class="code3">
WindowOpening-->
  case touches() : Wall
  else : Sill s('1,'1,windowSetback) t(0,0,'-1) [ i(openbox) Wall ] Window
    </pre>

Now, in case the geometry of the WindowOpening shape, which is a rectangular polygon generated by the typical facade split rules, touches another shape's geometry, the rule just invokes the Wall rule and does not create a window. Otherwise the rule is applied as before. The above figure shows the resulting building model on the right. <br>
Note that the default selector (all) has been used in the applied occlusion function. In the following the different types of occlusions i.e. selectors are described in more detail.</p>

<p>
<strong>Intra-occlusion:</strong> In case the selector is set to intra, the geometry of the current shape is tested against a practical selection of volumetric geometries generated with the ruleset. The evaluation of intra-occlusion queries is a two-pass process: <br>
<ol>
<li>The whole model is generated with all intra-occlusion queries evaluating to false, resulting in the so-called ghost shape tree.</li>
<li>The derivation is re-started, this time all intra-occlusion queries are evaluated by testing against the geometries of the following shapes in the ghost shape tree (note that only shapes with volumetric geometries which are over the user-defined volume threshold are considered):
<ul>
<li>Leaf shapes which are not children of the current shape.</li>
<li>Shapes where a component split has been applied and which are neither parents nor children of the current shape.</li>
</ul>
The pre-component split shapes are taken as occlusion geometries since this operation represent typically the transition from mass to surface, and furthermore consists of simple geometry which can be tested efficiently against occlusion. The current shape's predecessors and successors are not tested against, since they most likely occlude the current shape due to the top-down grammar modeling approach.</li>
</ol>

<p class="notes">
This algorithm does produce only partially correct results since the corresponding ghost shape tree should be updated as soon as an occlusion query returns true. However, he described method proved to be completely satisfying in all applied practical use case scenarios.</p>

<strong>Inter-occlusion:</strong> In case the selector is set to inter, the geometry of the current shape is tested against volumetric geometries generated on neighboring initial shapes. Therefore the initial shapes within a user-defined distance to the intial shape's bounding box are taken into account (the default distance is 20, see the settings in the Occlusion group in the 
<a href="../manual/ui/cep/grammarcore.html" class="internlink">Grammarcore preferences</a>).</li>
The evaluation of inter-occlusion on a set of initial shapes works as follows:
<ol>
<li>Find all initial shapes within the user-defined radius.</li>
<li>All corresponding models are generated with all inter-occlusion queries evaluating to false, resulting in the so-called ghost models. A ghost model consists of the geometries of the following shapes (and which are over the user-defined volume threshold):
<ul>
<li>Leaf shapes.</li>
<li>Shapes where a component split has been applied.</li>
</ul>
</li>
<li>The derivation is re-started, this time all inter-occlusion queries are evaluated against the geometries of the ghost models except the one which belongs to the current initial shape.
</li>
</ol>

<strong>Full-occlusion:</strong> In case the selector is set to all, first the intra-occlusion is evaluated and, if true, returned. Otherwise the inter-occlusion is evaluated in addition and its result returned.



  
          <h2>Examples
 
  </h2>
        <h3>Intra occlusion        </h3>
        <table summary="" class="twocol">
          <tr>
            <td class="twocol_l"><br>
            <img src="images/occlusion-intra.png" alt="3 ways to set color" width="298"></td>
            <td><pre class="code3">
            
            
            
Init --> extrude(15)
         split(x) { ~5 : Step }*
		
Step --> s('1, '0.7 * (split.index + 1), '1)
         comp(f) { side: Facade | top: X. }
	
Facade --> split(y) { 4 : Floor }*	

Floor --> case touches(intra):
             color("#ff0000") X
          else:
             X
</pre>
                <em>This example demonstrates the result of the <span class="cga_keyword">touches()</span> occlusion query on shapes 
                of one shape tree </em>(intra occlusion).</td>
          </tr>
  </table>
      
                


<!-- FOOTER -->
<p class="foot">Copyright &copy;2008-2015 Esri R&D Center Zurich. All rights reserved.</p>			  

<!-- END CENTERED CONTENT -->

</div>
</body>
</html>